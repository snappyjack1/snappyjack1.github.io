---
layout: post
title: Windows核心编程入门笔记
excerpt: "Windows核心编程入门笔记"
categories: [知识总结]
comments: true
---

#### 计算机体系结构分层入门讲解
计算机体系结构分层简图
```
-------------------------------------|
应用程序                             |
-------------------------------------|
内核                                 |(进程线程,内存,文件,网络,其他)
内核---------------------------------|
内核 虚拟驱动(针对一类设备写的驱动)  |(我们所写的驱动程序)
-------------------------------------|
硬件抽象层(HAL)                      |(硬件抽象层的作用就是屏蔽硬件的差异而存在)
-------------------------------------|
物理驱动层(针对各种具体设备写的驱动) |
-------------------------------------|
```
内核是操作系统的核心。操作系统的核心功能就是提供一个简单的硬件操作方法。我们所有程序，都是在操作硬件。不要以为你的控制台显示一个hello world的程序就不会操作硬件哦。输出字符要用到屏幕这个硬件，代码执行要用到CPU硬件，代码存储要用到CPU，代码文件要用到硬盘。如果要输入，还要用到键盘。这些都是硬件哦。然而，我们写hello world的时候，却感受不到硬件的存在。那是因为操作系统给我们提供了一个简便的操作硬件的方法。

计算机中的标准硬件，是操作系统必须要支持的.而且要给应用程序提供一个方便的使用方法，所以内核一般要将这些作为基础支持，放入到内核中。比如进程线程的管理、内存的管理、文件管理、网络管理等等，这些东西时时刻刻都要运行，所以这些内核功能都是时时刻刻待在内存中的。

内核也不是直接操作硬件的。在很多操作系统中，都有一个硬件抽象层（HAL），这个硬件抽象层的作用就是屏蔽硬件的差异而存在。这样可以让内核不用管具体是什么设备，都可以进行管理。

一类设备，可以有很多型号，我们都要支持，我们可以写一个通用的驱动程序来驱动设备正确的运行。也就是说，虚拟驱动在内核中，为其他内核模块提供操作硬件的方法。然后虚拟驱动再去调用硬件抽象层进一步操作硬件。通过传入的参数，硬件抽象层来确定操作的具体的某一个设备。然而对于具体设备如何操作，硬件抽象层还是不知道的。HAL只是知道可以操作哪个设备，知道一个通用的操作指令，然而不同的设备有不同的操作指令，所以HAL就会将通用操作指令交给物理驱动来执行。

物理驱动，通常由硬件厂商提供。因为物理驱动要很清楚硬件的结构，要能够准确无误的操作硬件，这不是一般人能够随便写的。没有硬件的结构，你是无法写物理驱动的。然而我们通常说的驱动开发，基本上是虚拟驱动级别的开发，也就是内核级别的驱动开发，而物理驱动开发，算是硬件级别的开发了。物理驱动基本上是一系列的电平时序，完成各个部件的操作。

#### 什么是操作系统内核
从上一节中,我们学习到操作系统内核是介于应用层和硬件层之间。硬件抽象层是介于系统和硬件之间的。操作系统的职责就是包装硬件的操作，让硬件操作起来更加方便。

操作系统内核也会通过几层的包装，让每一层都可以做一部分工作，从而降低操作硬件的难度，这个包括虚拟驱动、包括抽象硬件层

内核只是做来操作硬件的基本的操作，比如打开设备，关闭设备，向设备发送一个基本的命令。然而这个命令做什么用，是完成一个复杂功能的哪一个步骤，内核是不知道的。就好比，你只有发动机，没有轮子，车子跑不起来。
#### 操作系统内核有哪些类型以及特色
操作系统内核类型现在大概分为四种：单内核、微内核、混合内核（双内核）、外内核。

1. 单内核模式

这里的内核的单个不是CPU的单核双核的意思。这个单内核表示的意思是，整个内核是一个进程。这一个进程就是内核进程，其他进程都不是内核进程。仅此一个内核进程哦。而且，这个进程内部，包含了所有内核基本功能模块，如内存管理，文件管理，进程线程管理等。

那么这个内核进程无疑是系统最重要的进程了。如果这个进程挂了，可想而知，系统就崩溃了。我们平时看到Windows中一个进程出Bug崩溃了，这个进程就Over了。怎么办，关闭这个进程，然后重新启动这个进程呗。是的，对于普通进程来说，这个没有什么。然而对于系统进程来说，一旦内核进程出现了Bug，然后导致进程无法运行下去而崩溃了，这就表示系统崩溃了。

2. 微内核模式

采用了多进程多线程方式。一个微内核有好多个进程线程，每一个内核进程都是独立运行的，相互不依赖，相互不影响。这样一个内核进程崩溃，重启这个进程即可，系统还是正常运行。而且，不可能同时所有的内核进程都出bug崩溃的。这样无疑大大提高了系统的稳定性。

在Windows系统中，你可能经常遇到资源管理器崩溃，然后导致打开的文件夹和文件都关掉了。然而这个并不会导致系统死掉。系统自动让资源管理器重新启动就可以了。虽然可能造成一些损失，但是还是可以接受的。

微内核在嵌入式应用很广泛，如机器人、手机等。

3. 混合内核模式

混合内核就是将这些运行在用户态的内核代码放回内核，即使不是最基本的内核模块，但是经常会用到，所以放在内核中，虽然占内存会大点，但是却让执行速度提高了，用户体验就好了。微软的Windows操作系统内核就是混合内核模式。为什么说Windows系统越高级后要求的配置越高了，因为内核越来越大了，很多重要的功能都放在内核中，系统一启动，就占据了很大的内存了。如果配置低了，内核就跑不起来，系统就运行不好了。

4. 外内核模式

最后一种就是外内核。这种内核模式，现在只是在研究实验阶段.系统内核不抽象硬件，而是简单的管理硬件。它只管系统的保护和资源的复用。然后将硬件暴露给上层程序，这样的话，上层可以直接操作硬件。也就是说，我们的应用程序在外内核系统上，可以直接操作硬件。

#### 轻松理解用户态和内核态
Windows只使用其中的两个级别ring0和ring3，ring0只给操作系统内核用，ring3普通应用程序都能用

#### 什么是内核对象，什么是用户对象
内核态是系统内核程序运行时的状态，可以无所不能，而用户态程序只能执行普通的指令，访问有限的资源。自然而然，内核对象就是内核空间的对象，用户对象就是用户空间的对象。所谓的空间，也就是内存段。内核所在的内存空间与普通的用户程序所在的内存空间是隔离的，这样可以提高系统的稳定性。

#### 什么是触发状态
在每一个部件都是唯一的情况下，操作系统无法实现同时运行多个线程。因为一个CPU在某一时刻，只可能运行一个线程。CPU物理实体只有一个，这是硬件决定的。而线程很多都是双核甚至是四核的CPU，CPU硬件内有两个或者四个处理器执行单元，这样一来，可以同时运行两个或者四个线程。这样就是真正意义上的同时运行多个程序，这也是我们熟知的多任务系统。然而在一个CPU只有一个处理器执行单元情况下，一次只能执行一个线程。

核心编程触发状态的总结
```
进程、线程：
未触发（FALSE）：运行的时候
  触发（TRUE ）：结束运行的时候

事件触发：操作完成，等待的线程可以继续工作。
可等待的计时器：指定时间或间隔时间触发
信号量：对资源计数（最大资源数和当前可用资源数）
```
触发状态就是完成状态。等待资源的线程发现其他线程操作资源已经完成（处于触发状态）了，自己就可以继续执行了。
#### 用户态到内核态的穿越
应用程序从用户态切换到内核态，并不是应用程序本身的状态的变化。这个切换的过程，实际上是从功能的角度来看的，从功能实现的流程的角度看的。也就是说，用户态到内核态的切换，只是一个功能流程逻辑的变化。假如一个功能需要三个步骤，第一步是用户态完成的，第二步需要内核态完成，第三步又是用户态完成的。那么在第一步和第二步之间就会将用户态切换到内核态。内核态执行完后，返回来用户态继续执行第三步。所以，用户态切换到内核态事实上就是一次委托人办事的意思。只是委托办事的这个过程，算是应用程序完成功能的其中一个步骤而已。从功能实现来讲，应用程序的状态切换了一次。在内核态执行前，用户态会将必要的参数传递到内核中，供内核态的程序执行所需的操作。

这就好比是调用了系统的普通API一样。只不过这个API是内核态提供的API，而我们通常使用的win32API是用户态的，所以即使调用了win32的API，依然是用户态的。我们通常叫内核提供的API为系统服务接口，其实还是一种API，也是一些API函数。只是系统服务接口提供的函数可以帮应用程序操作硬件的。

用户态到内核态的切换，就是功能的其中一个环节让内核态程序来完成罢了。如果应用程序是调用系统API来请求完成某项功能的时候，此时是应用程序主动要执行内核态功能，这是主动切换状态的行为。而另外还有两种情况，虽然也是切换了状态，然而却是被动的。当程序执行时，一个异常出现了，会导致异常中断发生，此时程序无法继续正常执行下去，所以系统会中断用户态的应用的执行，转而进入了内核态来处理异常。而设备中断，是硬件产生的，通常也是很重要的。系统会打断正在执行的用户态的线程的执行，来先处理硬件的事情。
